# 4.1 데이터베이스의 기본

- DB는 일정한 규칙, 규약을 통해 저장된 데이터의 모음
- DBMS: 해당 DB를 제어, 관리하는 통합 시스템
- 데이터들은 각 DBMS마다 정의된 쿼리 언어를 사용해 삽입, 삭제, 수정, 조회를 수행할 수 있다.
- DB 위에 DBMS가 존재하며, 그 위에 응용 프로그램이 있다.
- MySQL(DBMS) - Node.js, php 등

## 4.1.1 엔터티

- 사람, 장소, 물건 등 여러 개의 속성을 지닌 명사
    - ex) 회원 - 이름, 아이디, 주소, 전화번호
- 약한 엔터티와 강한 엔터티
    - A가 혼자서는 존재하지 못하고 B의 존재 여부에 종속적이라면 A는 `약한 엔터티` B는 `강한 엔터티`


## 4.1.2 릴레이션

- DB에서 정보를 구분하여 저장하는 기본 단위
- RDB에서는 테이블, NoSQL에서는 컬렉션이라고 함
- 테이블과 컬렉션
    - DB는 크게 관계형 / NoSQL로 나눌 수 있다.
        - 관계형은 레코드- **테이블**- 데이터베이스의 구조
        - NoSQL(MongoDB)는 도큐먼트 - **컬렉션** - 데이터베이스의 구조

## 4.1.3 속성

- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
    - `차`라는 엔터티의 속성에는 차 넘버, 색깔, 차종 등이 있으며 이 중 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 됨

## 4.1.4 도메인

- 릴레이션에 포함된 각 속성들이 가질 수 있는 값의 집합
- `성별`이라는 속성이 있다면, 이 속성이 가질 수 있는 값은 [남, 여]라는 집합이 된다.
- 

## 4.1.5 필드와 레코드

- 회원이란 엔터티는 member라는 테이블로 `속성`인 이름, 아이디 등을 갖고 있으며 name, ID, address 등의 `필드`를 가진다.
- 테이블에 쌓이는 행 단위의 데이터를 레코드(튜플)이라고 한다.

- `책`이라는 엔터티를 정의하고 테이블 만들기
    - 속성: 책의 제목, 저자의 아이디, 출판년도, 장르, 생성 일시, 업데이트 일시만 있다고 가정
    - DB에 넣어 테이블로 만들기 위해서는 속성에 맞는 타입을 정의해야 한다.
```sql
CREATE TABLE book(
id INT NOT NULL AUTO_INCREMENT,
title VARCHAR(255),
author_id INT,
publishing_year VARCHAR(255),
genre VARCHAR(255),
created_at DATETIME,
updated_at DATETIME,
PRIMARY KEY(id)
);
```

### 필드 타입

- 필드는 타입을 가지며 타입들은 DBMS마다 다르다.
- MySQL을 기준으로, 대표적인 타입인 숫자, 날짜, 문자 타입에 대해 알아보자

### 숫자 타입

TINYINT, SAMLLINT, MEDIUMINT, INT, BIGINT 등이 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f7d9c6b-384a-4302-8b6b-66b5a01b0134/Untitled.png)

### 날짜 타입

DATE, DATETIME, TIMESTAMP 등이 있다.

- DATE
    - 날짜 부분은 있지만 시간 부분은 없는 값
    - 지원 범위: `1000-01-01 ~ 9999-12-31`
    - 3바이트

- DATETIME
    - 날짜 및 시간 부분을 모두 포함하는 값
    - 지원 범위: `1000-01-01 00:00:00 ~ 9999-12-31 23:59:59`
    - 8바이트

- TIMESTAMP
    - 날짜 및 시간 부분을 모두 포함하는 값
    - 지원 범위: `1970-01-01 00:00:01 ~ 2038-01-19 03:14:07`
    - 4바이트


### 문자 타입

CHAR, VARCHAR, TEXT, BLOB, ENUM, SET 등이 있다.

- CHAR와 VARCHAR
    - CHAR는 테이블 생성 시 선언한 길이로 고정되며, 길이는 `0~255`
    - VARCHAR는 입력된 데이터에 다라 용량을 가변시켜 저장한다. 길이는 `0~65,535`

  → 유동적인 길이의 데이터는 VARCHAR로, 그렇지 않은 데이터는 CHAR이 효율적이다.


- TEXT와 BLOB
    - 둘 다 큰 데이터를 저장할 때 쓰는 타입
    - TEXT는 큰 문자열에 쓰며 주로 게시판의 본문을 저장할 때 사용한다.
    - BLOB은 이미지, 동영상 등 큰 데이터 저장에 쓰인다.

  → 보통 아마존의 S3에 파일을 올리고, 파일의 경로를 VARCHAR로 저장하는 경우가 많다.

- ENUM과 SET
    - 모두 문자열을 열거한 타입이다.
    - **`ENUM`**은 ENUM(’x-small’, ‘small’, ‘medium’, ‘large’) 형태로 쓰이며 단일 선택만 가능하다.
    - ENUM 리스트에 없는 값을 삽입하면 빈 문자열이 삽입된다.
    - ‘x-small’ 등의 값이 0, 1 등으로 매핑되어 메모리를 적게 사용하는 이점이 있다.
    - **`SET`**은 ENUM과 비슷하나 여러 개의 데이터를 선택할 수 있고, 비트 단위의 연산이 가능하다.
    - 둘 다 공간적으로 이점이 있지만 애플리케이션이 수정되는 경우 DB의 ENUM, SET에서 정의한 목록을 수정해야 한다는 단점이 있다.

## 4.1.6 관계

DB에 테이블들은 서로의 관계가 정의되어 있으며 이런 관계는 **관계화살표**로 나타낸다.


### 1:1 관계

- 유저당 유저 이메일은 한 개씩 존재한다. → 이 경우 유저와 이메일은 1:1 관계가 된다.


- 1:1 관계는 테이블을 두 개로 나누어 테이블의 구조를 더 이해하기 쉽게 만들어 준다.

### 1:N 관계

- 쇼핑몰을 운영할 때, 한 유저당 여러 개의 상품을 장바구니에 담을 수 있다.

→ 이 경우 유저와 상품은 1:N 관계가 되며, 상품을 하나도 넣지 않는 0개의 경우도 있으니 0이 포함되는 관계화살표를 사용해야 한다.


### N:M 관계

- 학생은 강의를 여러개 들을 수 있으며, 강의도 여러 명의 학생을 포함할 수 있다.

→ 이 경우 학생과 강의는 N:M의 관계가 된다.

- N:M은 테이블을 직접 연결해서 구축하지 않고, 1:N, N:1 관계를 갖는 테이블 두 개로 나누어서 설정한다.

## 4.1.7 키

- 테이블 간의 관계를 명확히하고 테이블 자체의 인덱스를 위해 설정된 장치다.
- 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.

- 슈퍼키는 `유일성`이 있으며, 그 안에 포함된 후보키는 `최소성`까지 갖춘 키다.
- 후보키 중 기본키로 선택되지 못한 키는 `대체키`가 된다.
- `유일성`은 중복되는 값이 없으며, `최소성`은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것을 말한다.

### 기본키

- 유일성과 최소성을 만족하는 키
- 테이블 데이터 중 고유하게 존재하는 속성이며, 중복되어서는 안된다.
- 자연키, 인조키 중에 골라 설정한다.
- 자연키: 유저 테이블의 주민등록번호 등 속성중에 중복되지 않는 것을 자연스레 뽑다가 나오는 키 → 언젠가 변하는 속성을 가진다.
- 인조키: 유저 테이블에 인위적으로 아이디를 부여해서 고유 식별자를 생성하는 방식 → 불변한다.

### 외래키

- 다른 테이블의 기본키를 그대로 참조하는 값으로, 개체와의 관계를 식별하는 데 사용한다.

### 후보키

- 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

### 대체키

- 후보키가 두 개 이상일 경우, 어느 하나를 기본키로 지정하고 남은 후보키를 말한다.

### 슈퍼키

- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키
