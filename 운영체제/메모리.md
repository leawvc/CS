# 3.2 메모리

- CPU는 `메모리`에 올라와 있는 프로그램의 명령어를 실행할 뿐이다.
- 메모리 계층과 메모리 관리에 대해 알아보자

## 3.2.1 메모리 계층

- `레지스터`, `캐시`, `메모리`, `저장장치`로 구성되어 있다.

![image](https://user-images.githubusercontent.com/81108344/206995069-c161810f-6d72-48f3-83fe-f09fa6e18ad2.png)
- 레지스터: CPU 내부에 있는 작은 메모리로 휘발성과 속도가 빠르며 기억 용량이 가장 적다.
- 캐시: 휘발성과 속도가 빠르며 기억 용량이 적다.
- 주기억장치(메인 메모리, RAM): 휘발성, 속도, 기억 용량이 보통 수준
- 보조기억장치(HDD, SSD): 비휘발성, 속도 낮음, 기억 용량 많음



### 캐시

- 데이터를 미리 복사해 놓는 임시 저장소
- 메모리 - CPU 사이의 속도 차이가 크기 때문에 중간에 `레지스터 계층`을 두어 속도 차이를 해결한다. 이처럼 계층과 계층 사이에 있는 계층을 `캐싱 계층`이라고 한다.



### 지역성의 원리

- 캐시 계층을 두는 것 외에 캐시를 직접 설정할 수도 있다.
- 자주 사용하는 데이터를 기반으로 설정해야 하는데, 이에 대한 근거로 `지역성`이 있다.
    - 시간 지역성: 최근 사용한 데이터에 다시 접근하려는 특성
    - 공간 지역성: 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

### 캐시히트와 캐시미스

![image](https://user-images.githubusercontent.com/81108344/206995080-38a9ff21-dc0a-4669-a658-4978886b2596.png)
- 캐시히트를 하게되면 해당 데이터를 제어장치에서 가져오게 된다. CPU 내부 버스를 기반으로 작동하기 때문에 속도가 빠르다.
- 캐시미스가 발생되면 메모리에서 가져오는데, 이는 시스템 버스를 기반으로 작동하기 때문에 속도가 느리다.

### 웹 브라우저의 캐시

- 대표적으로 쿠키, 로컬 스토리지, 세션 스토리지가 있다.

### 쿠키

- 만료 기한이 있는 키-값 저장소
- 4KB까지 데이터를 저장할 수 있으며 만료기간을 정할 수 있다.
    - 주로 서버가 만료기간을 정한다.

### 로컬 스토리지

- 만료 기한이 없는 키-값 저장소.
- 10MB까지 저장 가능하며 웹 브라우저를 닫아도 유지되며 도메인 단위로 저장, 생성된다.
- 클라이언트에서만 수정 가능하다.

### 세션 스토리지

- 만료 기한이 없는 키-값 저장소
- 탭 단위로 스토리지를 생성하며, 탭을 닫으면 데이터가 삭제된다.
- 5MB 까지 저장 가능하며 클라이언트에서만 수정 가능하다.

## 3.2.2 메모리 관리

운영체제는 메모리를  관리하여 한정된 메모리를 극한으로 활용한다.

### 가상 메모리(virtual memory)

- 실제 가용 메모리 자원을 추상화하여 사용자들에게 매우 큰 메모리로 보이게 만드는 것

![image](https://user-images.githubusercontent.com/81108344/206995092-ac4e12ec-d38b-409f-837a-56ee31e39d43.png)
- 가상적으로 주어진 주소를 `가상 주소`, 실제 메모리 상에 있는 주소를 `실제 주소`라고 한다.
- 가상주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환된다.
- 가상메모리는 가상 주소, 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 `페이지 테이블`로 관리된다. → `TLB`를 이용해 속도 향상
- `TLB`: MMU에 포함된 주소 변환을 위한 캐시.

![image](https://user-images.githubusercontent.com/81108344/206995096-5bc546d2-cba7-4d10-944a-8ad085bc18e3.png)
- CPU는 가상 메모리를 다루고, 실제 해당 주소 접근 시 MMU 하드웨어 장치를 통해 물리 메모리에 접근해서 해당 데이터를 CPU에 전달한다.

### 스와핑

- 가상 메모리에는 존재하지만 실제 메모리(RAM)에 없는 데이터나 코드에 접근할 경우 **페이지 폴트가** 발생한다.
- 이때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드의 일부분을 마치 메모리처럼 불러와 쓰는 것을 스와핑이라고 한다. → 페이지 폴트가 일어나지 않은 것 처럼 만들어준다.

### 페이지 폴트

- 가상 메모리에는 존재하지만 실제 메모리(RAM)에 없는 데이터나 코드에 접근할 경우 발생한다.
- 페이지 폴트가 발생하면 운영체제는 그 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 것처럼 프로그램이 계속적으로 동작하게 해준다. ⇒ 스와핑

- 과정
1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생하여 운영체제에 알린다.
2. 운영체제는 CPU의 동작을 잠시 멈춘다.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인한다.
   없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾는다.
   물리 메모리에도 없다면 스와핑이 발동된다.
4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화한다.
5. 중단된 CPU를 다시 시작한다.

### 스레싱

![image](https://user-images.githubusercontent.com/81108344/206995372-f409b582-f68b-4c41-9615-4c1e80d01c5b.png)

- 메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어나서 스레싱이 발생한다.
    - 쉽게 말하면 빈번이 페이지 부재가 일어나 프로세스 수행에 필요한 시간보다 페이지 이동에 소요되는 시간이 더 많아 CPU 효율이 박살나는 현상
- 페이지 폴트가 일어나면 CPU 이용률이 낮아지며 운영체제로 하여금 더 많은 프로세스를 메모리에 올리게 한다.  → 이런 악순환이 반복되어 스레싱이 발생하는 것
- 해결 방안
    - 메모리를 늘리거나, HDD를 SSD로 변경한다.
    - 작업 세트, PFF

### 작업 세트

- 프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것  → 미리 로드할 경우 탐색 비용과 스와핑 횟수도 줄일 수 있다.
- 지역성은 시간, 공간 지역성으로 나뉜다.
    - 시간 지역성: 처음에 참조된 기억 장소가 가까운 미래에도 참조될 가능성이 높다
    - 공간 지역성: 어떤 기억 장소 하나가 참조될 때, 그 근처의 기억 장소가 계속 참조될 가능성이 높다.
- 이를 토대로 페이지 집합을 만들어 미리 메모리에 로드하는 것이다.

### PFF

프로세스에는 **너무 적은 프레임을 할당하면** 페이지 부재(page fault)가 자주 일어나게 될 것이고

**너무 많은 프레임을 할당하면** 메모리가 낭비되어 전체적인 시스템에 영향을 끼치게 될 것이다.

- 상한선과 하한선으로 페이지 폴트 빈도를 조절하는 방법
- 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다.

### 메모리 할당

- 메모리에 프로그램을 할당할 때 `시작 메모리 위치`, `메모리의 할당 크기`를 기반으로 할당하는데, `연속 할당`과 `불연속 할당`으로 나뉘게 된다.

### 연속 할당

- 메모리에 ‘연속적으로’ 공간을 할당하는 것
- 메모리를 미리 나누어 관리하는 `고정 분할 방식`과 `가변 분할 방식`이 존재한다.

- **고정 분할 방식**

메모리를 미리 나누어 관리하는 방식으로, 미리 나뉘기 때문에 융통성이 없다.

나눈 메모리 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 `내부 단편화`가 발생한다.

- **가변 분할 방식**

매 시점 프로그램의 크기에 맞기 동적으로 메모리를 나눠 사용한다.

메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 `외부 단편화` 현상이 발생한다.

### 불연속 할당

- 대표적으로 `페이징 기법`이 불연속 할당에 해당한다.
- 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것

### 페이징

- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다.
- 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해짐
    - 시스템에 여러 개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있어서 관리가 어렵다.
    - 하나의 프로세스라 해도 페이지마다 물리적 메모리에 올리는 위치가 제각각이라 논리적 주소를 물리적 주소로 변환하는 작업이 페이지 단위로 이루어져야 한다.

### 페이지 교체 알고리즘

- 메모리는 한정되어 있으므로 스와핑이 자주 일어난다. 스와핑은 페이지 교체 알고리즘을 기반으로 일어난다.

### 오프라인 알고리즘

- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
- 미래에 사용될 프로세스를 아는 것은 신의 영역이다.

### FIFO

- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법

### LRU

- 참조가 가장 오래된 페이지를 바꾼다. ‘오래된’ 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 한다는 문제점이 있다.
- MySQL의 버퍼 공간도 LRU 알고리즘을 사용

![image](https://user-images.githubusercontent.com/81108344/206995779-a6ce470b-8383-4708-87ee-cd916fa59d00.png)
### NUR

- LRU에서 발전한 알고리즘
- 0과 1을 가진 비트를 두며 1은 최근에 잠조되었음을, 0은 참조되지 않았음을 의미한다.
- 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하고, 해당 부분을 1로 바꾸는 알고리즘이다.

![image](https://user-images.githubusercontent.com/81108344/206995852-df812327-5dd1-4afd-8020-95c33807470a.png)

- 각 페이지마다 사용 여부를 확인하기 위해 두개의 비트를 사용한다.
    - 참조 비트(Reference bit), 변형 비트(Modified bit)
    - 참조 비트: 페이지가 호출되지 않았을 때는 0, 변경되었을 때는 1로 지정된다.
    - 변형 비트: 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1로 지정된다.
    - 다음과 같이 참조 비트와 변형 비트의 값에 따라 교체될 페이지의 순서가 결정된다.

  | 참조비트 | 변형비트 | 교체순서 |
      | --- | --- | --- |
  | 0 | 0 | 1 |
  | 0 | 1 | 2 |
  | 1 | 0 | 3 |
  | 1 | 1 | 4 |

### LFU(Least Frequently Used)

- 가장 참조 횟수가 적은 페이지를 교체하는 방식

### **SCR(Second Chance Replacement)**

- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 알고리즘
- 각 페이지마다 참조 비트를 두고, FIFO 기법을 이용하여 페이지 교체 수행중 참조 비트가 0일 경우에는 교체하고, 참조비트가 1일 경우에는 참조 비트를 0으로 지정한 후 FIFO 리스트의 맨 마지막으로 피드백시켜 다음 순서를 기다리게 한다.
